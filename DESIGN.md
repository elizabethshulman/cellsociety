Design
=======

Our configuration happens mostly inside our `FileProcessor.java` and `FileInfoExtractor.java` subclasses, which is where all of the initial set-up happens. Much of the maintenance of the simulation happens in FileProcessor as well, which happens when the user modifies the simulation dynamically from the Build-Your-Own mode.

Within `FileProcessor.java`, the design is broken up into three main parts that correspond to the three main parts of the `.xml` file. The first part is to read the header of the file, which contains information like who the author is, what the title of the simulation is, and what kind of simulation is actually being run. Additionally, this class handles all of the writing to a `.xml` file when a user chooses to save the current state of a simulation.

The `FileInfoExtractor.java` class is an interface that reads and writes simulation-specific information to and from the file. As an example, different simulations have different "global variables" (i.e., the segregation simulation has a satisfaction threshold that needs to be handled differently than the shark breeding time, fish breeding time, and shark starve time specified by the predator-prey simulation). The implementation of this class as an interface allows readers of our code to quickly understand what all of the classes that implement this interface to, which is the 3rd reason why interfaces are very cool in [Java Garage, Ch. 17](https://www2.cs.duke.edu/courses/compsci308/current/readings/java_garage_ch17.pdf). And yet we can still use the type of FileInfoExtractor for all the implementations of the class (polymorphism!) in FileProcessor.

The highest level class in our visualization component sits in a class called `Visualization.java`. It contains much of the logic for arranging the user interface on the screen and instantiates several components for display like the `HeaderBar` object, `LineGraph` object, and `Container` objects. It is also passed a `ControlPanel` object in the constructor and potentially a `Sidebar` object via a setter, which was a choice made in order to simplify a lot of the `EventHandler` objects that act on functions defined within our `Engine` class. The `ControlPanel` object being passed into the constructor is an example of a dependency injection because our injecting code in `Engine.java` could potentially choose to pass in a different instance of a `ControlPanel` in the future.

Arguably the most important visual components that the `Visualization` arranges on screen are the `Container` classes, which handle the logic pertaining to the visualization of the iteration-to-iteration simulation itself. `Container.java` is an abstract class that implements many of the methods that its subclasses have in common, while leaving the details of the specific implementation of simulations of a certain kind of shape to `SquareContainer.java`, `HexContainer.java`, and `TriangleContainer.java`. Those classes are required to implement `void drawGraph(Graph g)`, which is responsible for actually rendering the square, hexagon, or triangle objects on the screen. The `Container` class satisfies the Open-Closed Principle because it would be relatively straightforward to implement a new kind of shape, in the form of a `SeptagonContainer.java` that extends `Container`. This extends the application to a new kind of shape, but leaves the `Container.java` class closed for modification.

The logic for the bulk of our simulation is contained in the rulesVariants package, which houses the inheritance hierarchy representing all the various `Rules` objects for each specific simulation. Some of those classes also have `Manager` classes in the RulesVariantsManagers package, which was a way of breaking up code specific to certain simulations into smaller groups. As an example, there's a `PreyManager.java` class that contains shark-specific logic necessary for the PredatorPrey simulation. 

Every simulation also has a hierarchy of `Cell`s, which have different properties mostly relating to their color. The `Cell` objects are instantiated properly depending on the kind of simulation that is loaded.

###### How They Work Together
The Simulation component depends on the Configuration component building the `Map` of `Cell` objects and neighbors correctly depending on the kind of simulation (Game of Life, Spreading of Fire, etc.), the shape of the cells (triangle, hexagon, or square), the neighbor type chosen for the simulation (diagonals included or strictly orthogonal), and the edge type chosen for the board (finite or toroidal). Really the whole simulation depends on this action being performed properly -- without it, the simulations would be unable to run accurately. Concretely for us, the `Graph` objects depend on the `FileProcessor` having instantiated everything properly so that it can apply the rules in an appropriate manner. Beyond the constructor, the application also relies on the `FileProcessor` to update the `Graph` object after the user dynamically updates a simulation in the Build-Your-Own portion of the application. It's a bit odd to have something called a `FileProcessor` handling logic for updating a simulation, but it was behavior we chose because there was a lot of code in `FileProcessor` that handled constructing/editing of `Graphs`, and we felt it made sense for `Graph` to reuse that code.

The `Visualization` class depends on the Simulation properly applying the transformations to the `Graph` from iteration to iteration. It otherwise takes relatively little input, which we designed with the idea of keeping the visual components as unknowledgeable as possible about its peer classes and their activity. There's no need for `Visualization` to know anything about the application other than the state of the `Graph`, as that is the only thing that changes over the course of the simulation run. As long as the `EventHandler` objects are set properly and attached to the correct buttons, the `Visualization` really only depends on the latest state of the `Graph`.

Lastly, given that the `FileProcessor` loads new simulations, it isn't too dependent on anything really. It just needs the proper file to be passed into it (or saved to it), and it'll hum along just fine on its own.